


#' Adds the location of the a4a executable to the search path.  This function is called when FLa4a is attached
#'
#'
#' @param libname required
#' @param pkgname required
#' @return a pointer to the environment in which summaries of the data reside
#' @note \code{.onAttach} is intended to be used internally
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
#' @examples
#' # set up grapical options
#'  lattice.options(default.theme = geta4aLatticeOptions())
geta4aLatticeOptions <- function(...) 
{
  opts <- standard.theme(color = FALSE)
  opts <- modifyList(opts, list(strip.background = list(col = grey(0.95))))
  opts <- modifyList(opts, list(plot.symbol = list(pch = 16, col = "black", cex = 0.7)))
  opts <- modifyList(opts, list(axis.line = list(col = grey(0.8))))
  opts <- modifyList(opts, list(strip.border = list(col = grey(0.8))))

  opts
}

#' Adds the location of the a4a executable to the search path.  This function is called when FLa4a is attached
#'
#'
#' @param libname required
#' @param pkgname required
#' @return a pointer to the environment in which summaries of the data reside
#' @note \code{.onAttach} is intended to be used internally
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
plotIters <- function(object, nsamples = 5, ylab = "", by = "quant", col = 1, ...) {

  by <- match.arg(by, c("year","quant"))
  quant(object) <- "quant"

  x <- setdiff(c("year","quant"), by)

  doOne <- function(p, object) cbind(as.data.frame(apply(object, 1:5, quantile, p)), p = p)

  dat <- do.call(rbind, lapply(c(0.025, 0.5, 0.975), doOne, object = object))

  dat $ by <- dat[[by]]
  dat $ x <- dat[[x]]


  p1 <- xyplot(data ~ x | factor(by), group = p, data = dat,
               type = c("l","g"), scales = list(y = list(relation = "free")), 
               lwd = c(1,2,1), lty = c(2,1,2), col = col,
                ylab = ylab, xlab = x, as.table = TRUE, ...)
  if (nsamples > 0) {
  
    nsamples <- min(nsamples, min(9, dim(object)[6]))
    dat2 <- do.call(rbind, lapply(sample(dims(object) $ iter, nsamples), function(i) cbind(as.data.frame(object[,,,,,i]), p = i)))
    dat2 $ by <- dat2[[by]]
    dat2 $ x <- dat2[[x]]          

    p2 <- xyplot(data ~ x | factor(by), group = p, data = dat2,
                 type = "l", col =  brewer.pal(max(3, nsamples), "Set1"), lty = 1)
               
    p1 + p2
  } else {
    p1
  }
}


#' Reads the hessian file from any ADMB fit.  Used here with the a4a model.
#'
#' @param wkdir the location of the admb output
#' @return a list with the following elements
#' @note \code{getADMBHessian} is intended to be used internally
#' @author not Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
#' @examples
#' # load some data
#' data(ple4)
#' data(ple4.indices)
#' # choose a working directory
#' wkdir <- tempfile()
#' # do an 'assessment' fit wth default settings (not recomended!) and keep results in wkdir
#' fit <- a4a(stock = ple4, indices = ple4.indices, wkdir = wkdir, fit = "assessment")
#' 
#' hessInfo <- getADMBHessian(wkdir)
#' str(hessInfo)
#'
#' # calculate covariance matrix
#' Sigma <- solve(hessInfo $ hes)
#'
#' # plot correlation matrix of parameters
#' Cor <- cov2cor(Sigma)
#' diag(Cor) <- 0
#' colors <- colorRampPalette(c("blue","grey99","red"))(100)
#' image(Matrix(Cor), main = "correlations between parameter estimates", lwd = 0, col.regions = colors)
#' # end of example
getADMBHessian <- function(wkdir) {
## This function reads in all of the information contained in the
## admodel.hes file. Some of this is needed for relaxing the covariance
## matrix, and others just need to be recorded and rewritten to file so ADMB
## "sees" what itâ€™s expecting.
  filename <- file(paste0(wkdir,"/admodel.hes"), "rb")
  on.exit(close(filename))
  num.pars <- readBin(filename, "integer", 1)
  hes.vec <- readBin(filename, "numeric", num.pars^2)
  hes <- matrix(hes.vec, ncol=num.pars, nrow=num.pars)
  hybrid_bounded_flag <- readBin(filename, "integer", 1)
  scale <- readBin(filename, "numeric", num.pars)

  list(num.pars = num.pars, hes = hes, hybrid_bounded_flag = hybrid_bounded_flag, scale = scale)
}

#' Adds the location of the a4a executable to the search path.  This function is called when FLa4a is attached
#'
#'
#' @param libname required
#' @param pkgname required
#' @return a pointer to the environment in which summaries of the data reside
#' @note \code{.onAttach} is intended to be used internally
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
.onAttach <- function(libname, pkgname)
{
  ## TODO find out sep char for environment vars on macs
  sep <- if (os.type("linux")) ":" else if (os.type("windows")) ";" else ","
  path <- paste0(a4a.dir(), sep, Sys.getenv("PATH"))
  Sys.setenv(PATH=path)

  ## message with version number
  tbl <- library(help = FLa4a)$info[[1]]
  version <- gsub(" |[a-zA-z]|:", "", tbl[grep("Version:",tbl)])
  msg <- paste0("This is FLa4a ", version,". For overview type \'help(\"FLa4a-package\")\'\n")
  packageStartupMessage(msg)

  #
  check.executable()
}



#' returns the location on the file system of the ADMB executable
#'
#'
#' @param stock an FLStock object containing catch and stock information
#' @param index an FLIndex object containing survey indices 
#' @return a pointer to the environment in which summaries of the data reside
#' @note \code{a4a.dir} is intended to be used internally and based on the same function in INLA
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
a4a.dir <- function () 
{
  if (os.type("mac")) {
    fnm <- system.file(paste("bin/mac/", os.32or64bit(), "bit", sep = ""), package = "FLa4a")
  }
  else if (os.type("linux")) {
    fnm <- system.file("bin/linux", package = "FLa4a")
  }
  else if (os.type("windows")) {
    fnm <- system.file("bin/windows", package = "FLa4a")
  }
  else {
    stop("Unknown OS")
  }
  if (file.exists(fnm)) {
    return(fnm)
  }
  else {
    stop(paste("FLa4a installation error; no such file", fnm))
  }
}


#' returns TRUE if correct operating system is passed as an argument
#'
#'
#' @param type character string of operating system type
#' @return logical
#' @note \code{os.type} is intended to be used internally and based on the same function in INLA
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
os.type <- function (type = c("linux", "mac", "windows", "else")) 
{
  type = match.arg(type)
  if (type == "windows") {
    return(.Platform$OS.type == "windows")
  }
  else if (type == "mac") {
   result = (file.info("/Library")$isdir && file.info("/Applications")$isdir)
    if (is.na(result)) {
      result = FALSE
    }
    return(result)
  }
  else if (type == "linux") {
    return((.Platform$OS.type == "unix") && !os.type("mac"))
  }
  else if (type == "else") {
    return(TRUE)
  }
  else {
    stop("This shouldn't happen.")
  }
}


#' finds the size of the operating system addresses
#'
#' @return a character giving the size of the operating system address bus
#' @note \code{extractData} is intended to be used internally and based on the same function in INLA
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
os.32or64bit <- function () 
{
  return(ifelse(.Machine$sizeof.pointer == 4, "32", "64"))
}


#' Checks that the executable can be run by the user
#'
#' @return TRUE or FALSE.. primary function is to message the user.
#' @author Colin Millar \email{colin.millar@@jrc.ec.europa.eu}
#' @export
check.executable <- function() {
 if (os.type("linux")) {
   system(paste0("ls -l ", a4a.dir(), "/a4a > syslog.txt"))
   syslog <- readLines("syslog.txt")
   unlink("syslog.txt")
   
   is.x <- grepl("x", substring(syslog, 1,10))
 
   if (!is.x) {
     message(paste0(
       "Something has gone wrong!\n",
       "the a4a executable has the wrong permissions:\n\t",
          substring(syslog, 1,10), 
     "\nPlease change permissions (in a terminal) to a+x using\n",
       "\tchmod a+x ", a4a.dir(), "/a4a\n",
       "if you installed under sudo you will have to run:\n",
       "\tsudo chmod a+x ", a4a.dir(), "/a4a"))
     }
   
   return(is.x)
 } else { # windows
    return(TRUE)
 }   
}



#' coerces FLPar into list for call
#'
#' @return a list with each parametr as one element
#' @author EJ \email{ernesto.jardim@@jrc.ec.europa.eu}
#setAs("FLPar", "list", function(from){
#	lst <- split(from@.Data, 1:nrow(from))
#	names(lst) <- dimnames(from)[[1]]	
#	lst
#})

#setMethod("iterMedians", "FLPar", function(x){
#	apply(x, -match("iter", names(dimnames(x))), median)
#})




