






#' Hello 
#' @name logLik
#' @docType methods
#' @rdname logLik-methods
#' @aliases logLik,FLa4aFit-method
setMethod("logLik", signature(object = "a4aFit"),
  function(object, ...) 
  {  
    val <- -1 * unname(object @ fitSumm["nlogl",])
    attr(val, "nobs") <- unname(object @ fitSumm["nobs",])
    attr(val, "df") <- unname(object@fitSumm["nopar",])
    class(val) <- "logLik"
    val
 })

#' Hello 
#' @name show
#' @docType methods
#' @rdname show-methods
#' @aliases show,FLa4aFit-method
setMethod("plot", signature(x = "a4aFit", y = "FLStock"),
  function (x, y, ratio = 1.5, file = "", onefile = TRUE, what = c("N","F","Q","Res"), Ftext = FALSE, ...) 
  {

  # some checks
  
 
  # add fit to stock in case it hasnt been done
  y <- merge(y, x)


    if (file == "") {
      sub.dev.new <- function() dev.new(width = 7 * ratio, height = 7)
    }
    else { # will need different dev.new if file == pdf
      sub.dev.new <- function() NULL
      file <- if (onefile) paste0(file, ".pdf") else paste0(file, "%03d.pdf")
      pdf(onefile = onefile, file = file, width = 6 * ratio, height = 6)
    }

    ages  <- as.numeric(dimnames(stock.n(x)) $ age)
    years <- as.numeric(dimnames(stock.n(x)) $ year)

    cols <- 
     c(rgb(215, 48, 39, max = 255), 
       rgb(252, 141, 89, max = 255),
       rgb(254, 224, 144, max = 255),
       rgb(224, 243, 248, max = 255),
       rgb(145, 191, 219, max = 255),
       rgb(69, 117, 180, max = 255))

    # N plot
    zeros <- function(n) paste(rev(rep(c("0", "0", " 0"), length = n)), collapse = "")
    age.col <- colorRampPalette(cols[c(1, 6)])(length(ages))
      
  if ("N" %in% what) {  
    
    scale <- ceiling(max(log(stock.n(x)[drop=TRUE], 10))) - 2
    
    sub.dev.new()
    matplot(years, t(stock.n(x)[drop=TRUE]) * 10^{-scale},  
            ylab =paste0("N at age ('",zeros(scale),"s)"), xlab = "Year", 
            col = age.col,
            type ='l', lty = 1, lwd = 2, las = 1, main = "N-at-age in the Stock")
    lx = max(years) + diff(range(years))*0.04
    ly = (max(stock.n(x)[drop=TRUE]) + diff(range(stock.n(x)[drop=TRUE]))*0.04 ) * 10^{-scale}
    legend(lx, ly, legend = paste("age", ages), col = age.col, lty = 1, lwd = 2, xjust = 1, yjust = 1)

  }

  if ("F" %in% what) {  

    fest <- harvest(x)[drop=TRUE]

    sub.dev.new()
    # F plot
    matplot(years, t(fest),  
            ylab = "F at age", xlab = "Year", 
            col = colorRampPalette(cols[c(1, 6)])(length(ages)),
            type = 'l', lty = 1, lwd = 2, las = 1, main = "F-at-age")
    lx = max(years) + diff(range(years))*0.04
    ly = max(fest) + diff(range(fest))*0.04
    legend(lx, ly, legend = paste("age", ages), col = age.col, lty = 1, lwd = 2, xjust = 1, yjust = 1)


    sub.dev.new()
    # another F plot
    p <- matrix.plot(fest, cols = cols, xlab = "Year", ylab = "Age", main = "F-at-age", ymin = min(ages), xmin = min(years), text = Ftext)
    print(p)

    sub.dev.new()
    # Yet another F plot
    p <- wireframe(fest, drape = TRUE, colorkey = FALSE,
             screen = list(z = 240, x = -60), 
             col.regions = colorRampPalette(rev(cols))(100),
             panel.aspect = 1/ratio, aspect=c(length(years)/length(ages), 2),
             ylab = "Year", xlab = "Age", zlab = "F", main = "F-at-age",
             #par.settings = list(axis.line = list(col = "transparent")),
             par.box = c(col = "transparent"))
    print(p)

  }

#    sub.dev.new()
    # fbar plot
#    plotError(years, fbar(y)[,,,,,"mean",drop=TRUE], sqrt(fbar(x)[,,,,,"var",drop=TRUE]), 
#              ylab = 'Fbar', xlab = "Year", cols = colorRampPalette(cols[5:6])(3))

#    sub.dev.new()
    # ssb plot
#    plotError(years, ssb(y)[,,,,,"mean",drop=TRUE] * 1e-3, sqrt(ssb(x)[,,,,,"var",drop=TRUE]) * 1e-3, 
#              ylab = "SSB ('000 tonnes)", xlab = "Year", cols = colorRampPalette(cols[5:6])(3))

  if ("Q" %in% what) {  

    # q plots
    for (i in 1:length(x @ logq)) {
      qest <- logq(x)[[i]]
      qages  <- as.numeric(dimnames(qest) $ age)
      qyears <- as.numeric(dimnames(qest) $ year)

      sub.dev.new()
      matplot(qages, qest[drop=TRUE],  
              ylab="log catchability", xlab="Age", main = names(x @ logq)[i],
              col = colorRampPalette(cols[c(1, 6)])(length(qyears)),
              type ='l', lty = 1, lwd = 2, las = 1)

      p <- wireframe(qest[drop=TRUE], drape = TRUE, colorkey = FALSE,
             # screen value tuned to ple4.indices[1:2]
             screen = list(z = ifelse(i==1, -1, 1) * 30, x = -60), 
             col.regions = colorRampPalette(rev(cols))(100),
             panel.aspect = 1/ratio, ylab = "Year", xlab = "Age", 
             zlab = "log catchability", main = paste("log catchability-at-age of", names(x @ logq)[i]),
             par.box = c(col = "transparent"))
      sub.dev.new()
      print(p) 
    }

    # q plots
    sub.dev.new()
    rec.age <- range(y)["min"]
    ssb.x <- ssb(y)[,seq(rec.age) - length(ssb(y)) - 1][drop=TRUE]
    rec.y <- rec(y)[,-seq(rec.age)][drop=TRUE]
    plot(ssb.x, rec.y, pch = 19, ann = FALSE, xlim = c(0, max(ssb.x)), ylim = c(0, max(rec.y)))
    title(main = "Stock and Recruitment", xlab = "SSB", ylab = paste("Recruitment (age ", rec.age, ")", sep = ""))
    # TODO  add in stock recruit fit if a model was used.
  }

  if ("Res" %in% what) {  

    sub.dev.new()
    
    par(oma = c(4,0,0,0))
    
    # Residual plot 
    div <- list(c(1,1), c(2,1), c(3,1), c(2,2), c(3,2), c(3,2), c(3,3), c(3,3), c(3,3), c(4,3), c(4,3), c(4,3))
    nind <- length(x @ logq)
    op <- par(mfrow = div[[nind + 1]], mar = c(4,4,1,2), mgp = c(2,1,0))
    ylim <- range(as.numeric(dimnames(stock.n(x)) $ age)) + c(-.5, .5)
    xlim <- range(as.numeric(dimnames(stock.n(x)) $ year)) + c(-.5, .5)

    res <- catch.lres(x)
    ages  <- as.numeric(dimnames(res) $ age)
    years <- as.numeric(dimnames(res) $ year)

    bp(rep(years, each = length(ages)), rep(ages, length(years)), 
       c(res[drop=TRUE]), 
       ylim = ylim, xlim = xlim, 
       xlab = 'year', ylab = 'Age', main = "Catch", 
       scale = 3, las = 1)

    

    for(i in 1:nind) {
      res <- index.lres(x)[[i]]
      ages  <- as.numeric(dimnames(res) $ age)
      years <- as.numeric(dimnames(res) $ year)

      bp(rep(years, each = length(ages)), rep(ages, length(years)), 
         c(res[drop=TRUE]), 
         ylim = ylim, xlim = xlim, 
         xlab = 'year', ylab = 'Age', main = names(x @ logq)[i], 
         scale = 3, las = 1)
    }

    mtext("Standardised residuals: Positive (red) and negative (blue).  \n50% of dots should be light coloured, 95% should be light and medium, \n5% of dots should be dark.", 
          side = 1, line = 6, adj = 0)

  }

    if (file != "") dev.off()
  }
)


#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname logq-methods
#'
#' @examples
#' data(ple4)
#' genFLQuant(harvest(ple4), method = "ac")
setGeneric("logq", function(object, ...) standardGeneric("logq"))

#' @rdname logq-methods
#' @aliases logq,FLa4aFit-method
setMethod("logq", signature(object = "a4aFit"),
  function(object) {
	object @ logq
  })


#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname catch.hat-methods
setGeneric("catch.hat", function(object, ...) standardGeneric("catch.hat"))


#' Hello 
#' @name catch.hat
#' @docType methods
#' @rdname catch.hat-methods
#' @aliases catch.hat,FLa4aFit-method
setMethod("catch.hat", signature(object = "a4aFit"),
  function (object, ...) 
  {
    exp(object @ catch.lhat)
  })


q#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname index.hat-methods
setGeneric("index.hat", function(object, ...) standardGeneric("index.hat"))


#' Hello 
#' @name index.hat
#' @docType methods
#' @rdname index.hat-methods
#' @aliases index.hat,FLa4aFit-method
setMethod("index.hat", signature(object = "a4aFit"),
  function (object, ...) 
  {
    lapply(object @ index.lhat, exp)
  })


#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname catch.lhat-methods
setGeneric("catch.lhat", function(object, ...) standardGeneric("catch.lhat"))


#' Hello 
#' @name catch.lhat
#' @docType methods
#' @rdname catch.lhat-methods
#' @aliases catch.lhat,FLa4aFit-method
setMethod("catch.lhat", signature(object = "a4aFit"),
  function (object, ...) 
  {
    object @ catch.lhat
  })


#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname index.lhat-methods
setGeneric("index.lhat", function(object, ...) standardGeneric("index.lhat"))


#' Hello 
#' @name index.lhat
#' @docType methods
#' @rdname index.lhat-methods
#' @aliases index.lhat,FLa4aFit-method
setMethod("index.lhat", signature(object = "a4aFit"),
  function (object, ...) 
  {
    object @ index.lhat
  })





#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname catch.lvar-methods
setGeneric("catch.lvar", function(object, ...) standardGeneric("catch.lvar"))


#' Hello 
#' @name catch.lvar
#' @docType methods
#' @rdname catch.lvar-methods
#' @aliases catch.lvar,FLa4aFit-method
setMethod("catch.lvar", signature(object = "a4aFit"),
  function (object, ...) 
  {
    object @ catch.lvar
  })


q#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname index.lvar-methods
setGeneric("index.lvar", function(object, ...) standardGeneric("index.lvar"))


#' Hello 
#' @name index.lvar
#' @docType methods
#' @rdname index.lvar-methods
#' @aliases index.lvar,FLa4aFit-method
setMethod("index.lvar", signature(object = "a4aFit"),
  function (object, ...) 
  {
    object @ index.lvar
  })


#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname index.lres-methods
setGeneric("index.lres", function(object, ...) standardGeneric("index.lres"))


#' Hello 
#' @name index.lres
#' @docType methods
#' @rdname index.lres-methods
#' @aliases index.lres,FLa4aFit-method
setMethod("index.lres", signature(object = "a4aFit"),
  function (object, type = "scaled", ...) 
  {
    type <- match.arg(type, c("scaled", "unscaled"))
    if (type == "scaled") {
      object @ index.lres
    } else if (type == "unscaled") {
      out <- object @ index.lres
      for (i in 1:length(out)) {
        out[[i]] <- out[[i]] * sqrt(object @ index.lvar[[i]])
      }
      out
    }
  })


#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname catch.lres-methods
setGeneric("catch.lres", function(object, ...) standardGeneric("catch.lres"))


#' Hello 
#' @name catch.lres
#' @docType methods
#' @rdname catch.lres-methods
#' @aliases catch.lres,FLa4aFit-method
setMethod("catch.lres", signature(object = "a4aFit"),
  function (object, type = "scaled", ...) 
  {
    type <- match.arg(type, c("scaled", "unscaled"))
    if (type == "scaled") {
      object @ catch.lres
    } else if (type == "unscaled") {
      object @ catch.lres * sqrt(object @ catch.lvar)
    }
  })




#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname coef-methods
#'
#' @examples
#' data(ple4)
#' genFLQuant(harvest(ple4), method = "ac")
setGeneric("coef", function(object, ...) standardGeneric("coef"))

#' @rdname coef-methods
#' @aliases coef,FLa4aFit-method
setMethod("coef", signature(object = "a4aFitSA"),
  function(object) {
	  coef(object @ pars)
  })


#' @rdname coef-methods
#' @aliases coef,FLa4aFit-method
setMethod("coef", signature(object = "SCAPars"),
  function(object) {
    list(
      stkmodel = object @ stkmodel @ params,
      qmodel   = lapply(object @ qmodel, function(x) x @ params),
      vmodel   = lapply(object @ vmodel, function(x) x @ params)
    )
  })



#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname coef-methods
#'
#' @examples
#' data(ple4)
#' genFLQuant(harvest(ple4), method = "ac")
setGeneric("simulate", useAsDefault = stats::simulate)

#' @rdname coef-methods
#' @aliases coef,FLa4aFit-method
setMethod("simulate", signature(object = "a4aFitSA"),
  function(object, nsim = 1, seed = NULL) {
    simulate(object @ pars)
  })


#' @rdname coef-methods
#' @aliases coef,FLa4aFit-method
setMethod("simulate", signature(object = "SCAPars"),
  function(object, nsim = 1, seed = NULL, iter = 1) {

    # sanity checks
    iter <- as.integer(iter)
    if (iter > dim(object @ stkmodel @ params)[2] | iter < 0) {
      message("supplied value of iter is not sensible... simulating from iter = 1")
      iter <- 1
    }

    if (!exists(".Random.seed", envir = .GlobalEnv, inherits = FALSE)) 
        runif(1)
    if (is.null(seed)) 
        RNGstate <- get(".Random.seed", envir = .GlobalEnv)
    else {
        R.seed <- get(".Random.seed", envir = .GlobalEnv)
        set.seed(seed)
        RNGstate <- structure(seed, kind = as.list(RNGkind()))
        on.exit(assign(".Random.seed", R.seed, envir = .GlobalEnv))
    }
    
    # get parameter estimates
    stkpars <- object @ stkmodel @ params
    qpars   <- lapply(object @ qmodel, function(x) x @ params)
    vpars   <- lapply(object @ vmodel, function(x) x @ params)
    
    # get parameter variance matrices
    stkvars <- object @ stkmodel @ vcov
    qvars   <- lapply(object @ qmodel, function(x) x @ vcov)
    vvars   <- lapply(object @ vmodel, function(x) x @ vcov)

    # simulate some new params from the first iteration only!
    if (dim(stkpars)[2] > 1) message("Note: only one iteration is being used for simulations.\n\tIf you want to change this change the iter argument")
    stkparsim <- t(mvrnorm(nsim, c(stkpars[,iter]), stkvars[,,iter]))
    qparsim <- lapply(seq_along(qpars), function(i) t(mvrnorm(nsim, c(qpars[[i]][,iter]), qvars[[i]][,,iter])))
    vparsim <- lapply(seq_along(vpars), function(i) t(mvrnorm(nsim, c(vpars[[i]][,iter]), vvars[[i]][,,iter])))

    # load simpars into a SCAPars object and return
    out <- object
    
    out @ stkmodel @ params <- propagate(object @ stkmodel @ params[,1], nsim)
    out @ stkmodel @ params[] <- c(stkparsim)

    for (i in seq_along(out @ qmodel)) {
      out @ qmodel[[i]] @ params <- propagate(object @ qmodel[[i]] @ params[,1], nsim)
      out @ qmodel[[i]] @ params[] <- c(qparsim[[i]])
    }

    for (i in seq_along(out @ vmodel)) {
      out @ vmodel[[i]] @ params <- propagate(object @ vmodel[[i]] @ params[,1], nsim)
      out @ vmodel[[i]] @ params[] <- c(vparsim[[i]])
    }

    return(out)
  })




#' Calculate the median accross iterations
#'
#' @param object an FLQuant with iters
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return an FLQuant
#' 
#' @seealso \code{\link{print}} and \code{\link{cat}}
#' 
#' @export
#' @docType methods
#' @rdname vcov-methods
#'
#' @examples
#' data(ple4)
#' genFLQuant(harvest(ple4), method = "ac")
setGeneric("vcov", function(object, ...) standardGeneric("vcov"))

#' @rdname vcov-methods
#' @aliases vcov,FLa4aFit-method
setMethod("vcov", signature(object = "a4aFit"),
  function(object) {
	  object @ covariance[1:object@fit.sum["nopar"], 1:object@fit.sum["nopar"]]
  })



setMethod("+", c("FLStock", "a4aFit"), function(e1, e2) 
{

  niters <- dims(e1) $ iter
  if (niters > 1) stop("adding a basic a4aFit object only makes sence with 1 iteration")

  years <- range(e1)[c("minyear","maxyear")]
  ages <- range(e1)[c("min","max")]

  dmns <- list(age    = paste(ages[1]:ages[2]), 
               year   = paste(years[1]:years[2]),
               unit   = "unique", 
               season = "all", 
               area   = "unique", 
               iter = paste(1:niters))
               
  dms <- unname(c(dims(e1) $ age, dims(e1) $ year, 1, 1, 1, dims(e1) $ iter))

  stock.n(e1) <- stock.n(e2)
  catch.n(e1) <- catch.n(e2)
  harvest(e1) <- harvest(e2)
  
  catch(e1) <- computeCatch(e1)
  stock(e1) <- computeStock(e1)
  
  e1
})


setMethod("+", c("FLStock", "a4aFitSA"), function(e1, e2) 
{
  e1 + pars(e2)
})



setMethod("+", c("FLStock", "SCAPars"), function(e1, e2) 
{

  niters <- dims(e1) $ iter

  years <- range(e1)[c("minyear","maxyear")]
  ages <- range(e1)[c("min","max")]

  
  #
  # Build design matrix for catches only
  #
  full.df <- expand.grid(age  = ages[1]:ages[2],
                         year = years[1]:years[2])[2:1]
 
#  if (!is.null(covar)) {
#  # add in covariates to data.frame - it is easiest to provide covariates in one list
#  tmp <- 
#    lapply(seq_along(covar), 
#      function(i) {
#        x <- as.data.frame(covar[[i]])[c(1,2,7)]
#        if (length(unique(x $ age)) == 1) x <- x[names(x) != "age"]
#        if (length(unique(x $ year)) == 1) x <- x[names(x) != "year"]
#        names(x) <- gsub("data", names(covar)[i], names(x))
#        x
#      })
#  covar.df <- tmp[[1]]
#  for (i in seq(length(covar) - 1)) covar.df <- merge(covar.df, tmp[[i + 1]], all = TRUE, sort = FALSE)
#
#  full.df <- merge(full.df, covar.df, all.x = TRUE, all.y = FALSE)
#  } 

  # make sure contrasts are set to sumto zero to match fit
  opts <- options(contrasts = c(unordered = "contr.sum", ordered = "contr.poly")) 
  
  # f model matrix
  Xf <- Matrix(getX(e2 @ stkmodel @ fMod, full.df))

  # initial age structure model matrix
  Xny1 <- getX(e2 @ stkmodel @ n1Mod, subset(full.df, year == min(year) & age > min(age)))
    
  # now separate the sr model element
  facs <- strsplit(as.character(e2 @ stkmodel @ srMod)[length(e2 @ stkmodel @ srMod)], "[+]")[[1]]
  facs <- gsub("(^ )|( $)", "", facs) # remove leading and trailing spaces
  a4as <- grepl(paste("(^",c("bevholt", "ricker","hockey","geomean"),"[(])", collapse = "|", sep = ""), facs)

  # internal r model matrix
  if (sum(a4as) == 0) rmodel <- e2 @ stkmodel @ srMod else rmodel <- ~ factor(year) 
  Xr <- getX(rmodel, subset(full.df, age == min(age)))

  # reset options
  options(opts)

  # always simulate from b distribution for SA class.  If you want fitted values do FLStock + a4aFit(a4aFitSA)
  b.sim <- Matrix(simulate(e2, nsim = niters) @ stkmodel @ params @ .Data)

  # matrix of predictions
  Xbeta <- bdiag(Xf, Xny1, Xr) %*% b.sim

  # plusgroup?
  plusgrp <- !is.na(range(e1)["plusgroup"]) && range(e1)["plusgroup"] >= range(e1)["max"]

  # unpack m - good for recycling
  Ms   <- c(m(e1) @ .Data)
 
  # build stock
  Fs <- Ns <- array(exp(Xbeta[1:nrow(Xf),]), dim = c(diff(ages)+1, diff(years)+1, ncol(Xbeta)))
  Ns[] <- NA
  Ns[-1,1,] <- array(exp(Xbeta[nrow(Xf) + 1:nrow(Xny1),]), dim = c(diff(ages), 1, ncol(Xbeta)))
  Ns[1,,] <- array(exp(Xbeta[nrow(Xf) + nrow(Xny1) + 1:nrow(Xr),]), dim = c(1, diff(years)+1, ncol(Xbeta)))
  Zs <- Fs + Ms
  for (a in 2:dim(Ns)[1]) {
    Ns[a,-1,] <- Ns[a-1, 1:diff(years),] * exp( - Zs[a-1, 1:diff(years),] )
  }
  # if plus group
  if (plusgrp) {
    for (y in 1:diff(years)) Ns[a,y+1,] <- Ns[a,y+1,] + Ns[a, y,] * exp( - Zs[a, y,] )
  } 
  # apply centering
  Ns <- Ns * exp(e2 @ stkmodel @ centering)
 
  zfrac <- Fs / Zs * (1 - exp(-Zs))

  dmns <- list(age    = paste(ages[1]:ages[2]), 
               year   = paste(years[1]:years[2]),
               unit   = "unique", 
               season = "all", 
               area   = "unique", 
               iter = paste(1:niters))
               
  dms <- unname(c(dims(e1) $ age, dims(e1) $ year, 1, 1, 1, dims(e1) $ iter))

  stock.n(e1) <- FLQuant(Ns, dim = dms, dimnames = dmns, units = units(catch.n(e1)))
  catch.n(e1) <- FLQuant(zfrac * Ns, dim = dms, dimnames = dmns, units = units(catch.n(e1)))
  harvest(e1) <- FLQuant(Fs, dim = dms, dimnames = dmns, units = "f")
  
  catch(e1) <- computeCatch(e1)
  stock(e1) <- computeStock(e1)
  
  e1
})
