#==================================================================== 
# Experimental code for plotting
#==================================================================== 
#setMethod("plot", signature(x = "a4aFit", y = "FLStock"),
#  function (x, y, ratio = 1.5, file = "", onefile = TRUE, 
#            #what = c("N","F","Q","Res"),
#            what = c("N", "F", "Res"), 
#            Ftext = TRUE, ask = TRUE, ...) 
#  {

#  op <- par(ask = ask, no.readonly = TRUE)

#  ages  <- as.numeric(dimnames(stock.n(x)) $ age)
#  years <- as.numeric(dimnames(stock.n(x)) $ year)

#  cols <- 
#     c(rgb(215, 48, 39, max = 255), 
#       rgb(252, 141, 89, max = 255),
#       rgb(254, 224, 144, max = 255),
#       rgb(224, 243, 248, max = 255),
#       rgb(145, 191, 219, max = 255),
#       rgb(69, 117, 180, max = 255))

#  zeros <- function(n) paste(rev(rep(c("0", "0", " 0"), length = n)), collapse = "")
#  age.col <- colorRampPalette(cols[c(1, 6)])(length(ages))
#      
#  if ("N" %in% what) {  
#    # N plot
#    scale <- ceiling(max(log(stock.n(x)[drop=TRUE], 10))) - 2
#    
#    matplot(years, t(stock.n(x)[drop=TRUE]) * 10^{-scale},  
#            ylab =paste0("N at age ('",zeros(scale),"s)"), xlab = "Year", 
#            col = age.col,
#            type ='l', lty = 1, lwd = 2, las = 1, main = "N-at-age in the Stock")
#    lx = max(years) + diff(range(years))*0.04
#    ly = (max(stock.n(x)[drop=TRUE]) + diff(range(stock.n(x)[drop=TRUE]))*0.04 ) * 10^{-scale}
#    legend(lx, ly, legend = paste("age", ages), col = age.col, lty = 1, lwd = 2, xjust = 1, yjust = 1)

#  }

#  if ("F" %in% what) {  

#    fest <- harvest(x)[drop=TRUE]

#    # F plot
#    matplot(years, t(fest),  
#            ylab = "F at age", xlab = "Year", 
#            col = colorRampPalette(cols[c(1, 6)])(length(ages)),
#            type = 'l', lty = 1, lwd = 2, las = 1, main = "F-at-age")
#    lx = max(years) + diff(range(years))*0.04
#    ly = max(fest) + diff(range(fest))*0.04
#    legend(lx, ly, legend = paste("age", ages), col = age.col, lty = 1, lwd = 2, xjust = 1, yjust = 1)


#    # another F plot
#    p <- matrix.plot(fest, cols = cols, xlab = "Year", ylab = "Age", main = "F-at-age", ymin = min(ages), xmin = min(years), text = Ftext)
#    print(p)

#    # Yet another F plot
#    p <- wireframe(fest, drape = TRUE, colorkey = FALSE,
#             screen = list(z = 240, x = -60), 
#             col.regions = colorRampPalette(rev(cols))(100),
#             panel.aspect = 1/ratio, aspect=c(length(years)/length(ages), 2),
#             ylab = "Year", xlab = "Age", zlab = "F", main = "F-at-age",
#             #par.settings = list(axis.line = list(col = "transparent")),
#             par.box = c(col = "transparent"))
#    print(p)

#  }

##    sub.dev.new()
#    # fbar plot
##    plotError(years, fbar(y)[,,,,,"mean",drop=TRUE], sqrt(fbar(x)[,,,,,"var",drop=TRUE]), 
##              ylab = 'Fbar', xlab = "Year", cols = colorRampPalette(cols[5:6])(3))

##    sub.dev.new()
#    # ssb plot
##    plotError(years, ssb(y)[,,,,,"mean",drop=TRUE] * 1e-3, sqrt(ssb(x)[,,,,,"var",drop=TRUE]) * 1e-3, 
##              ylab = "SSB ('000 tonnes)", xlab = "Year", cols = colorRampPalette(cols[5:6])(3))

#  if ("Q" %in% what) {  

#    # q plots
#    for (i in 1:length(x @ logq)) {
#      qest <- logq(x)[[i]]
#      qages  <- as.numeric(dimnames(qest) $ age)
#      qyears <- as.numeric(dimnames(qest) $ year)

#      matplot(qages, qest[drop=TRUE],  
#              ylab="log catchability", xlab="Age", main = names(x @ logq)[i],
#              col = colorRampPalette(cols[c(1, 6)])(length(qyears)),
#              type ='l', lty = 1, lwd = 2, las = 1)

#      p <- wireframe(qest[drop=TRUE], drape = TRUE, colorkey = FALSE,
#             # screen value tuned to ple4.indices[1:2]
#             screen = list(z = ifelse(i==1, -1, 1) * 30, x = -60), 
#             col.regions = colorRampPalette(rev(cols))(100),
#             panel.aspect = 1/ratio, ylab = "Year", xlab = "Age", 
#             zlab = "log catchability", main = paste("log catchability-at-age of", names(x @ logq)[i]),
#             par.box = c(col = "transparent"))
#      print(p) 
#    }

#    # q plots
#    rec.age <- range(y)["min"]
#    ssb.x <- ssb(y)[,seq(rec.age) - length(ssb(y)) - 1][drop=TRUE]
#    rec.y <- rec(y)[,-seq(rec.age)][drop=TRUE]
#    plot(ssb.x, rec.y, pch = 19, ann = FALSE, xlim = c(0, max(ssb.x)), ylim = c(0, max(rec.y)))
#    title(main = "Stock and Recruitment", xlab = "SSB", ylab = paste("Recruitment (age ", rec.age, ")", sep = ""))
#    # TODO  add in stock recruit fit if a model was used.
#  }

#  if ("Res" %in% what) {  
#    
#    par(oma = c(4,0,0,0))
#    
#    # Residual plot 
#    div <- list(c(1,1), c(2,1), c(3,1), c(2,2), c(3,2), c(3,2), c(3,3), c(3,3), c(3,3), c(4,3), c(4,3), c(4,3))
#    nind <- length(x @ index)
#    op2 <- par(mfrow = div[[nind + 1]], mar = c(4,4,1,2), mgp = c(2,1,0), no.readonly = TRUE)
#    ylim <- range(as.numeric(dimnames(stock.n(x)) $ age)) + c(-.5, .5)
#    xlim <- range(as.numeric(dimnames(stock.n(x)) $ year)) + c(-.5, .5)

#    res <- log(catch.n(y) / catch.n(x))
#    ages  <- as.numeric(dimnames(res) $ age)
#    years <- as.numeric(dimnames(res) $ year)

#    bp(rep(years, each = length(ages)), rep(ages, length(years)), 
#       c(res[drop=TRUE]), 
#       ylim = ylim, xlim = xlim, 
#       xlab = 'year', ylab = 'Age', main = "Catch", 
#       scale = 3, las = 1)

#    

##    for(i in 1:nind) {
##      res <- index.lres(x)[[i]]
##      ages  <- as.numeric(dimnames(res) $ age)
##      years <- as.numeric(dimnames(res) $ year)

##      bp(rep(years, each = length(ages)), rep(ages, length(years)), 
##         c(res[drop=TRUE]), 
##         ylim = ylim, xlim = xlim, 
##         xlab = 'year', ylab = 'Age', main = names(x @ logq)[i], 
##         scale = 3, las = 1)
##    }

#    mtext("Standardised residuals: Positive (red) and negative (blue).  \n50% of dots should be light coloured, 95% should be light and medium, \n5% of dots should be dark.", 
#          side = 1, line = 6, adj = 0)
#    par(op2)
#  }
#  
#  par(op)
# 
#})

#==================================================================== 
#    coef  methods
#==================================================================== 

#' Methods to extract and replace the model coefficients
#' @name coef
#' @docType methods
#' @rdname coef-methods

setGeneric("coef", function(object, ...) standardGeneric("coef"))

#' @rdname coef-methods
#' @aliases coef,a4aFitSA-method
setMethod("coef", signature(object = "a4aFitSA"),
  function(object) {
	  coef(pars(object))
  })


#' @rdname coef-methods
#' @aliases coef,SCAPars-method
setMethod("coef", signature(object = "SCAPars"),
  function(object) {
    list(
      stkmodel = coef(stkmodel(object)),
      qmodel   = coef(qmodel(object)),
      vmodel   = coef(vmodel(object))
    )
  })

#' @rdname coef-methods
#' @aliases coef,a4aStkParams-method
setMethod("coef", signature(object = "a4aStkParams"),
  function(object) {
      object @ params
  })

#' @rdname coef-methods
#' @aliases coef,submodels-method
setMethod("coef", signature(object = "submodels"),
  function(object) {
      lapply(object, coef)
  })


#' @rdname coef-methods
#' @aliases coef,submodel-method
setMethod("coef", signature(object = "submodel"),
  function(object) {
      object @ params
  })

#==================================================================== 
#    coef<-  methods
#==================================================================== 

setGeneric("coef<-", function(object, ..., value) standardGeneric("coef<-"))

#' @rdname coef-methods
#' @aliases coef<-,a4aFitSA,numeric-method
setMethod("coef<-", signature(object = "a4aFitSA", value = "numeric"),
  function(object, ..., value) {
    coef(object @ pars) <- value
    object
  })


#' @rdname coef-methods
#' @aliases coef<-,SCAPars,numeric-method
setMethod("coef<-", signature(object = "SCAPars", value = "numeric"),
  function(object, ..., value) {
    v <- coef(object)
    old <- unlist(v)
    new <- rep_len(unlist(value), length = length(old))
    
    coef(object @ stkmodel) <- new[grep("stkmodel", names(old))]
    coef(object @ qmodel) <- new[grep("qmodel.", names(old))]
    coef(object @ vmodel) <- new[grep("vmodel.", names(old))]

    object
  })


#' @rdname coef-methods
#' @aliases coef<-,a4aStkParams,numeric-method
setMethod("coef<-", signature(object = "a4aStkParams", value = "numeric"),
  function(object, ..., value) {    
    object @ params[] <- value
    object
  })

#' @rdname coef-methods
#' @aliases coef<-,submodels,numeric-method
setMethod("coef<-", signature(object = "submodels", value = "numeric"),
  function(object, ..., value) {
    v <- coef(object)
    old <- unlist(v)
    new <- rep_len(unlist(value), length = length(old))
    
    for (i in seq_along(object)) {
      object[[i]] @ params[] <- new[grep(object[[i]] @ name, names(old))]  
    }
    object
  })


#' @rdname coef-methods
#' @aliases coef<-,submodel,numeric-method
setMethod("coef<-", signature(object = "submodel", value = "numeric"),
  function(object, ..., value) {
      object @ params[] <- value
      object
  })

#==================================================================== 
#    vcov  methods
#==================================================================== 

#' Methods to extract and replace the variance-covariance matrix
#' @name vcov
#' @rdname vcov-methods
#' @aliases vcov,a4aFitSA-method
setMethod("vcov", signature(object = "a4aFitSA"),
  function(object) {
    vcov(pars(object))
  })


#' @rdname vcov-methods
#' @aliases vcov,SCAPars-method
setMethod("vcov", signature(object = "SCAPars"),
  function(object) {
    list(
      stkmodel = vcov(stkmodel(object)),
      qmodel   = vcov(qmodel(object)),
      vmodel   = vcov(vmodel(object))
    )
  })

#' @rdname vcov-methods
#' @aliases vcov,a4aStkParams-method
setMethod("vcov", signature(object = "a4aStkParams"),
  function(object) {
      object @ vcov
  })

#' @rdname vcov-methods
#' @aliases vcov,submodels-method
setMethod("vcov", signature(object = "submodels"),
  function(object) {
      lapply(object, vcov)
  })


#' @rdname vcov-methods
#' @aliases coef,submodel-method
setMethod("vcov", signature(object = "submodel"),
  function(object) {
      object @ vcov
  })

#==================================================================== 
#    vcov<-  methods
#==================================================================== 

#' @rdname vcov-methods
#' @aliases vcov<-,a4aFitSA,numeric-method
setMethod("vcov<-", signature(object = "a4aFitSA", value = "numeric"),
  function(object, ..., value) {
    vcov(object @ pars) <- value
    object
  })


#' @rdname vcov-methods
#' @aliases vcov<-,SCAPars,numeric-method
setMethod("vcov<-", signature(object = "SCAPars", value = "numeric"),
  function(object, ..., value) {
    v <- vcov(object)
    old <- unlist(v)
    new <- rep_len(unlist(value), length = length(old))
    
    vcov(object @ stkmodel) <- new[grep("stkmodel", names(old))]
    vcov(object @ qmodel) <- new[grep("qmodel.", names(old))]
    vcov(object @ vmodel) <- new[grep("vmodel.", names(old))]

    object
  })


#' @rdname vcov-methods
#' @aliases vcov<-,a4aStkParams,numeric-method
setMethod("vcov<-", signature(object = "a4aStkParams", value = "numeric"),
  function(object, ..., value) {    
    object @ vcov[] <- value
    object
  })

#' @rdname vcov-methods
#' @aliases vcov<-,submodels,numeric-method
setMethod("vcov<-", signature(object = "submodels", value = "numeric"),
  function(object, ..., value) {
    v <- vcov(object)
    old <- unlist(v)
    new <- rep_len(unlist(value), length = length(old))
    
    for (i in seq_along(object)) {
      object[[i]] @ vcov[] <- new[grep(object[[i]] @ name, names(old))]  
    }
    object
  })

#' @rdname vcov-methods
#' @aliases vcov<-,submodel,numeric-method
setMethod("vcov<-", signature(object = "submodel", value = "numeric"),
  function(object, ..., value) {
      object @ vcov[] <- value
      object
  })

#==================================================================== 
#    predict  methods
#==================================================================== 

#' Predict methods for stock assessment fits
#' @name predict
#' @rdname predict-methods
#' @aliases predict,a4aFitSA-method
setMethod("predict", signature(object = "a4aFitSA"),
  function(object) {
    predict(pars(object))
  })


#' @rdname predict-methods
#' @aliases predict,SCAPars-method
setMethod("predict", signature(object = "SCAPars"),
  function(object) {
    list(
      stkmodel = predict(stkmodel(object)),
      qmodel   = predict(qmodel(object)),
      vmodel   = predict(vmodel(object))
    )
  })

#' @rdname predict-methods
#' @aliases predict,a4aStkParams-method
setMethod("predict", signature(object = "a4aStkParams"),
  function(object) {
      ages <- range(object)["min"]:range(object)["max"]
      years <- range(object)["minyear"]:range(object)["maxyear"]
      cnames <- rownames(coef(object))
      df <- expand.grid(age = ages,
                        year = years)
      X <- getX(object @ fMod, df)
      b <- coef(object)[grep("fMod", cnames)]
      niter <- dim(b)[2] # reuse this for the others
      fit <- exp(c(X %*% b))
      harvest <- 
        FLQuant(array(fit, dim = c(length(ages), length(years), 1, 1, 1, niter), 
                      dimnames = list(age = ages, year = years, 
                                         unit = "unique", season = "all", area = "unique",
                                         iter = seq(niter))),
                units = "f")


      X <- getX(object @ n1Mod, data.frame(age = ages[-1]))
      b <- coef(object)[grep("n1Mod", cnames)]
      fit <- exp(c(rbind(NA, X %*% b)) + object @ centering)
      ny1 <-       
        FLQuant(array(fit, dim = c(length(ages), 1, 1, 1, 1, niter), 
                      dimnames = list(age = ages, year = years[1], 
                                         unit = "unique", season = "all", area = "unique",
                                         iter = seq(niter))))


      X <- getX(object @ srMod, data.frame(year = years))
      b <- coef(object)[grep("rMod", cnames)]
      fit <- c(exp(c(X %*% b) + object @ centering))
      rec <-     
        FLQuant(array(fit, dim = c(1, length(years), 1, 1, 1, niter), 
                      dimnames = list(age = ages[1], year = years, 
                                         unit = "unique", season = "all", area = "unique",
                                         iter = seq(niter))))


      list(harvest = harvest, rec = rec, ny1 = ny1)
})

#' @rdname predict-methods
#' @aliases predict,submodels-method
setMethod("predict", signature(object = "submodels"),
  function(object, ...) {
      lapply(object, predict)
  })


#' @rdname predict-methods
#' @aliases predict,submodel-method
setMethod("predict", signature(object = "submodel"),
  function(object, ...) {
      ages <- range(object)["min"]:range(object)["max"]
      years <- range(object)["minyear"]:range(object)["maxyear"]
      df <- expand.grid(age = ages,
                        year = years)
      X <- getX(object @ Mod, df)
      b <- coef(object)
      niter <- dim(b)[2]
      fit <- exp(c(X %*% b) + object @ centering)
      FLQuant(array(fit, dim = c(length(ages), length(years), 1, 1, 1, niter), 
                         dimnames = list(age = ages, year = years, 
                                         unit = "unique", season = "all", area = "unique",
                                         iter = seq(niter))))
  })

#==================================================================== 
#    simulate  methods
#==================================================================== 

#setGeneric("simulate", useAsDefault = stats::simulate)
setGeneric("simulate", useAsDefault = simulate)


#' Simulation methods for stock assessment fits
#'
#' @name simulate
#' @rdname simulate-methods
#' @aliases simulate,a4aFitSA-method
setMethod("simulate", signature(object = "a4aFitSA"),
  function(object, nsim = 1, iter = NULL) {
    out <- object
    out @ pars <- simulate(pars(object), nsim = nsim, iter = iter)
    
    # now get catch.n, stock.n, harvest and index
    preds <- predict(out)
    out @ harvest <- preds $ stkmodel $  harvest
    out @ stock.n <- out @ catch.n <- out @ harvest
    out @ stock.n[1,] <- preds $ stkmodel $  rec
    out @ stock.n[-1,1] <- preds $ stkmodel $ ny1[-1,]

    # plusgroup?
    dms <- dims(object)
    plusgrp <- !is.na(dms $ plusgroup) && dms $ plusgroup >= dms $ max
  
    # build stock
    Zs <- harvest(out) + m(out)
    for (a in 2:dms $ age) {
      out @ stock.n[a,-1] <- out @ stock.n[a-1, 1:(dms $ year-1)] * exp( - Zs[a-1, 1:(dms $ year-1)] )
    }
    # if plus group
    if (plusgrp) {
      for (y in 1:(dms $ year-1)) 
        out @ stock.n[a,y+1,] <- out @ stock.n[a,y+1,] + out @ stock.n[a, y,] * exp( - Zs[a, y,] )
    } 
 
    # calculate catch
    zfrac <- harvest(out) / Zs * (1 - exp(-Zs))
    out @ catch.n <- zfrac * out @ stock.n
    
    # work out indices
    out @ index <- preds $ qmodel
    for (i in seq(out @ index)) {
      iages <- rownames(out @ index[[i]])
      iyears <- colnames(out @ index[[i]])
      when <- mean(range(qmodel(pars(out))[[i]])[c("startf", "endf")])
      out @ index[[i]] <- (out @ stock.n * exp(-Zs * when))[iages, iyears] * out @ index[[i]]
    }

    out
})

#' @rdname simulate-methods
#' @aliases simulate,SCAPars-method
setMethod("simulate", signature(object = "SCAPars"),
  function(object, nsim = 1, iter = NULL) {    
    out <- object
    
    out @ stkmodel <- simulate(object @ stkmodel, nsim = nsim, iter = iter)
    out @ qmodel <- simulate(object @ qmodel, nsim = nsim, iter = iter)
    out @ vmodel <- simulate(object @ vmodel, nsim = nsim, iter = iter)

    out
  })

#' @rdname simulate-methods
#' @aliases simulate,a4aStkParams-method
setMethod("simulate", signature(object = "a4aStkParams"),
  function(object, nsim = 1, iter = NULL) {    

    # sanity checks
    if (is.null(iter)) {
      if (nsim == 1) iter <- seq(dim(object @ params)[2])
      if (nsim > 1) iter <- 1
    } else
    {
      if (nsim == 1) {
        if (any(iter > dim(object @ params)[2]) | any(iter < 0)) {
          message("supplied values of iter are not sensible... simulating from all iters")
          iter <- seq_along(dim(object @ params)[2])
        }
    } else
      {
        if (length(iter) > 1) stop("if nsim > 1 iter must be of length 1")
        if (iter > dim(object @ params)[2] | iter < 0) {
          message("supplied values of iter are not sensible... simulating from iter = 1")
          iter <- 1
        }
      }
    }
    
    # get parameter estimates
    b <- coef(object)
    
    # get parameter variance matrices
    V <- vcov(object)

    # simulate some new params from the first iteration only!
    if (dim(V)[3] == 1) {
      itervar <- rep(1, length(iter))
    } else {
      itervar = iter
    }
    parsim <-
      sapply(seq_along(iter),
        function(i) 
          t(mvrnorm(nsim, c(b[,iter[i]]), V[,,itervar[i]])))

    
    # load simpars into a SCAPars object and return
    out <- object
    
    if (nsim == 1) { 
      out @ params <- object @ params
    } else {
      out @ params <- propagate(object @ params[,iter], nsim)
    }
    out @ params[] <- c(parsim)

    ####
    # note we set the variance matrices to zero
    # since having a variance no longer makes sense...
    ####
    vcov(out) <- 0

    return(out)
})

#' @rdname simulate-methods
#' @aliases simulate,submodels-method
setMethod("simulate", signature(object = "submodels"),
  function(object, nsim = 1, iter = NULL) {
    out <- lapply(object, simulate, nsim = nsim, iter = iter)
    submodels(out)
  })

#' @rdname simulate-methods
#' @aliases simulate,submodel-method
setMethod("simulate", signature(object = "submodel"),
  function(object, nsim = 1, iter = NULL) {

    # sanity checks
    if (is.null(iter)) {
      if (nsim == 1) iter <- seq(dim(object @ params)[2])
      if (nsim > 1) iter <- 1
    } else
    {
      if (nsim == 1) {
        if (any(iter > dim(object @ params)[2]) | any(iter < 0)) {
          message("supplied values of iter are not sensible... simulating from all iters")
          iter <- seq_along(dim(object @ params)[2])
        }
    } else
      {
        if (length(iter) > 1) stop("if nsim > 1 iter must be of length 1")
        if (iter > dim(object @ params)[2] | iter < 0) {
          message("supplied values of iter are not sensible... simulating from iter = 1")
          iter <- 1
        }
      }
    }
    
    # get parameter estimates
    b <- coef(object)
    
    # get parameter variance matrices
    V <- vcov(object)

    # simulate some new params from the first iteration of V only!
    if (dim(V)[3] == 1) {
      itervar <- rep(1, length(iter))
    } else {
      itervar = iter
    }
    parsim <- 
      sapply(seq_along(iter), 
            function(i) 
              t(mvrnorm(nsim, c(b[,iter[i]]), V[,,itervar[i]])))

    # load simpars into a submodel object and return
    out <- object
    
    if (nsim == 1) { 
      out @ params <- object @ params
    } else {
      out @ params <- propagate(object @ params[,iter], nsim)
    }
    out @ params[] <- c(parsim)

    ####
    # note we set the variance matrices to zero
    # since having a variance no longer makes sense...
    ####
    vcov(out) <- 0

    return(out)
})

#==================================================================== 
# "+" methods
#==================================================================== 

#' + methods
#' @name +
#' @rdname addition-methods
#' @aliases +,a4aFit-method
setMethod("+", c("FLStock", "a4aFit"), function(e1, e2) 
{

  niters <- dims(e1) $ iter
  if (niters > 1) stop("adding a basic a4aFit object only makes sence with 1 iteration")

  stock.n(e1) <- stock.n(e2)
  catch.n(e1) <- catch.n(e2)
  harvest(e1) <- harvest(e2)
  
  catch(e1) <- computeCatch(e1)
  stock(e1) <- computeStock(e1)
  
  e1
})

#' @rdname addition-methods
#' @aliases +,FLStock,a4aFitSA-method
setMethod("+", c("FLStock", "a4aFitSA"), function(e1, e2) 
{
  e1 + pars(e2)
})

#' @rdname addition-methods
#' @aliases +,FLStock,SCAPars-method
setMethod("+", c("FLStock", "SCAPars"), function(e1, e2) 
{

  niters <- dims(e1) $ iter
  niters2 <- dim(e2 @ stkmodel @ params)[2]
  if (niters > 1 & niters2 == 1) {
    nsim = niters
  } else {
    nsim = 1
    if (niters > niters2) stop("oh oh")
    if (niters == 1 & niters2 > 0) {
      niters <- niters2
      e1 <- propagate(e1, niters)
    }
  }

  # build up a4aFitSA to simulate from
  mod <- new("a4aFitSA")
  mod @ pars <- e2
  mod @ catch.n <- catch.n(e1)
  mod @ stock.n <- stock.n(e1)
  mod @ harvest <- harvest(e1)
  mod @ range <- range(e1)

  simstock <- simulate(mod, nsim = nsim)  

  catch.n(e1) <- catch.n(simstock)
  stock.n(e1) <- stock.n(simstock)
  harvest(e1) <- harvest(simstock)
    
  catch(e1) <- computeCatch(e1)
  stock(e1) <- computeStock(e1)
  
  e1
})


#' @rdname addition-methods
#' @aliases +,FLIndices,a4aFit-method
setMethod("+", c("FLIndices", "a4aFit"), function(e1, e2) 
{

  #niters <- dims(e1) $ iter
  #if (niters > 1) stop("adding a basic a4aFit object only makes sence with 1 iteration")

  for (i in seq(FLIndices)) {
    index(e1[[i]]) <- index(e2)[[i]]
    #catch.n(e1[[i]]) <- index(e1[[i]]) * effort(e1[[1]])
    #index.q(e1[[1]])
    #sel.pattern(e1[[1]]) 
    #??index.var(e1[[1]])
  }
    
  e1
})

#' @rdname addition-methods
#' @aliases +,FLIndices,a4aFitSA-method
setMethod("+", c("FLIndices", "a4aFitSA"), function(e1, e2) 
{
  e1 + pars(e2)
})


#' @rdname addition-methods
#' @aliases +,FLIndices,SCAPars-method
setMethod("+", c("FLIndices", "SCAPars"), function(e1, e2) 
{

  niters <- dims(e1) $ iter
  niters2 <- dim(e2 @ stkmodel @ params)[2]
  if (niters > 1 & niters2 == 1) {
    nsim = niters
  } else {
    nsim = 1
    if (niters > niters2) stop("oh oh")
    if (niters == 1 & niters2 > 0) {
      niters <- niters2
      e1 <- propagate(e1, niters)
    }
  }

  stop("not implemented yet")

  #FLIndices(out)
})

